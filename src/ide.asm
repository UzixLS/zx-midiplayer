; https://wiki.osdev.org/ATA_PIO_Mode
;
; Registers
; # Access  Function                Description                                                            Param. size LBA28/LBA48
; 0 R/W     Data                    Read/Write PIO data bytes                                              16-bit / 16-bit
; 1 R       Error                   Used to retrieve any error generated by the last ATA command executed  8-bit / 16-bit
; 1 W       Features                Used to control command specific interface features                    8-bit / 16-bit
; 2 R/W     Sector Count            Number of sectors to read/write (0 is a special value)                 8-bit / 16-bit
; 3 R/W     Sector Number / LBAlo   This is CHS / LBA28 / LBA48 specific                                   8-bit / 16-bit
; 4 R/W     Cylinder Low / LBAmid   Partial Disk Sector address                                            8-bit / 16-bit
; 5 R/W     Cylinder High / LBAhi   Partial Disk Sector address                                            8-bit / 16-bit
; 6 R/W     Drive / Head / LBAex    Used to select a drive and/or head. Supports extra address/flag bits   8-bit / 8-bit
; 7 R       Status                  Used to read the current status                                        8-bit / 8-bit
; 7 W       Command                 Used to send ATA commands to the device                                8-bit / 8-bit
;
; Error Register
; Bit     Abbreviation    Function
; 0       AMNF            Address mark not found
; 1       TKZNF           Track zero not found
; 2       ABRT            Aborted command
; 3       MCR             Media change request
; 4       IDNF            ID not found
; 5       MC              Media changed
; 6       UNC             Uncorrectable data error
; 7       BBK             Bad Block detected
;
; Drive / Head Register
; Bit     Abbreviation    Function
; 0 - 3                   In CHS addressing, bits 0 to 3 of the head. In LBA addressing, bits 24 to 27 of the block number
; 4       DRV             Selects the drive number
; 5       1               Always set
; 6       LBA             Uses CHS addressing if clear or LBA addressing if set
; 7       1               Always set
;
; Status Register
; Bit     Abbreviation    Function
; 0       ERR             Indicates an error occurred. Send a new command to clear it (or nuke it with a Software Reset)
; 1       IDX             Index. Always set to zero
; 2       CORR            Corrected data. Always set to zero
; 3       DRQ             Set when the drive has PIO data to transfer, or is ready to accept PIO data
; 4       SRV             Overlapped Mode Service Request
; 5       DF              Drive Fault Error (does not set ERR)
; 6       RDY             Bit is clear when drive is spun down, or after an error. Set otherwise
; 7       BSY             Indicates the drive is preparing to send/receive data (wait for it to clear). In case of 'hang' (it never clears), do a software reset
; Technically, when BSY is set, the other bits in the Status byte are meaningless. It is also generally a Bad Idea to test the "Seek Complete" (DSC) bit, because it has been deprecated and replaced by the newer SRV bit
;
Ide_Reg_Data                   equ 0
Ide_Reg_Error                  equ 1
Ide_Reg_Features               equ 1
Ide_Reg_Sectors                equ 2
Ide_Reg_Lbalo                  equ 3
Ide_Reg_SectorN                equ 3
Ide_Reg_Lbamid                 equ 4
Ide_Reg_CylinderNlo            equ 4
Ide_Reg_Lbahi                  equ 5
Ide_Reg_CylinderNhi            equ 5
Ide_Reg_DriveHead              equ 6
Ide_Reg_Status                 equ 7
Ide_Reg_Command                equ 7
Ide_Cmd_Identify_Device        equ #ec
Ide_Cmd_Read_Sectors           equ #20
Ide_Cmd_Read_Sectors_Ext       equ #24
Ide_Cmd_Write_Sectors          equ #30
Ide_Cmd_Write_Sectors_Ext      equ #34
Ide_Cmd_Set_Max_Addr           equ #f9
Ide_Cmd_Set_Max_Addr_Ext       equ #37
Ide_Cmd_Init_Device_Parameters equ #91
Ide_St_BSY                     equ #80
Ide_St_DRDY                    equ #40
Ide_St_DF                      equ #20
Ide_St_DSC                     equ #10
Ide_St_DRQ                     equ #08
Ide_St_CORR                    equ #04
Ide_St_IDX                     equ #02
Ide_St_ERR                     equ #01
Ide_Id_General                 equ 0
Ide_Id_NumCyls                 equ 1*2
Ide_Id_NumHeads                equ 3*2
Ide_Id_NumSecs                 equ 6*2
Ide_Id_Serial                  equ 10*2
Ide_Id_Firmware                equ 23*2
Ide_Id_Model                   equ 27*2
Ide_Id_Caps                    equ 49*2
Ide_Id_Lba                     equ 60*2



; IN  -  A - driver | disk_number
; OUT -  F - Z on success, NZ on fail
; OUT - AF - garbage
; OUT - BC - garbage
; OUT - DE - garbage
; OUT - HL - garbage
ide_driver_select:
    push af                                                 ;
    srl a                                                   ;
    cp DISK_DRIVER_DIVIDE>>1                                ;
    jr z, .divide                                           ;
    cp DISK_DRIVER_NEMOIDE>>1                               ;
    jr z, .nemoide                                          ;
    cp DISK_DRIVER_SMUC>>1                                  ;
    jr z, .smuc                                             ;
    pop de                                                  ;
    ret                                                     ;
.divide:
    ld hl, idedrv_divide                                    ;
    jr .setup                                               ;
.nemoide:
    ld hl, idedrv_nemoide                                   ;
    jr .setup                                               ;
.smuc:
    ld a, #77 : ld bc, #ffba : call trdos_out               ;
    ld hl, idedrv_smuc                                      ;
    jr .setup                                               ;
.setup:
    ld de, idedrv_table                                     ;
    ld bc, idedrv_table_end - idedrv_table                  ;
    ldir                                                    ;
.master_slave:
    pop de                                                  ;
    ld a, #e0                                               ; master
    bit 0, d                                                ;
    jr z, 1f                                                ;
    ld a, #f0                                               ; slave
1:  ld (ide_init.D+1), a                                    ;
    ld (ide_drive_select.D+1), a                            ;
    ld (ide_read_block.D+1), a                              ;
    jp ide_drive_select                                     ;

idedrv_table:
idedrv_out_lbaex_drive_head: jp 0
idedrv_out_command:          jp 0
idedrv_in_status:            jp 0
idedrv_out_sector_count_lba: jp 0
idedrv_read_256b:            jp 0
idedrv_table_end:

idedrv_divide:
    jp idedrv_divide_out_lbaex_drive_head
    jp idedrv_divide_out_command
    jp idedrv_divide_in_status
    jp idedrv_divide_out_sector_count_lba
    jp idedrv_divide_read_256b
idedrv_nemoide:
    jp idedrv_nemoide_out_lbaex_drive_head
    jp idedrv_nemoide_out_command
    jp idedrv_nemoide_in_status
    jp idedrv_nemoide_out_sector_count_lba
    jp idedrv_nemoide_read_256b
idedrv_smuc:
    jp idedrv_smuc_out_lbaex_drive_head
    jp idedrv_smuc_out_command
    jp idedrv_smuc_in_status
    jp idedrv_smuc_out_sector_count_lba
    jp idedrv_smuc_read_256b

idedrv_divide_out_lbaex_drive_head:
    ld bc, #ffbb                         ; Ide_Reg_DriveHead
    out (c), a                           ;
    ret                                  ;
idedrv_nemoide_out_lbaex_drive_head:
    ld bc, #ffd0                         ; Ide_Reg_DriveHead
    out (c), a                           ;
    ret                                  ;
idedrv_smuc_out_lbaex_drive_head:
    ld bc, #febe                         ; Ide_Reg_DriveHead
    call trdos_out                       ;
    ret                                  ;

idedrv_divide_out_command:
    ld bc, #ffbf                         ; Ide_Reg_Command
    out (c), a                           ;
    ret                                  ;
idedrv_nemoide_out_command:
    ld bc, #fff0                         ; Ide_Reg_Command
    out (c), a                           ;
    ret                                  ;
idedrv_smuc_out_command:
    ld bc, #ffbe                         ; Ide_Reg_Command
    call trdos_out                       ;
    ret                                  ;

idedrv_divide_in_status:
    ld bc, #ffbf                         ; Ide_Reg_Status
    in a, (c)                            ;
    ret                                  ;
idedrv_nemoide_in_status:
    ld bc, #fff0                         ; Ide_Reg_Status
    in a, (c)                            ;
    ret                                  ;
idedrv_smuc_in_status:
    ld bc, #ffbe                         ; Ide_Reg_Status
    call trdos_in                        ;
    ret                                  ;

; IN  - A    - sectors count
; IN  - EIX  - lba
; OUT - AF   - garbage
; OUT - BC   - garbage
idedrv_divide_out_sector_count_lba:
    ld bc, #ffab                         ; Ide_Reg_Sectors
    out (c), a                           ;
    ld a, ixl                            ;
    ld c, #af                            ; Ide_Reg_Lbalo
    out (c), a                           ;
    ld a, ixh                            ;
    ld c, #b3                            ; Ide_Reg_Lbamid
    out (c), a                           ;
    ld a, e                              ;
    ld c, #b7                            ; Ide_Reg_Lbahi
    out (c), a                           ;
    ret                                  ;
; IN  - A    - sectors count
; IN  - EIX  - lba
; OUT - AF   - garbage
; OUT - BC   - garbage
idedrv_nemoide_out_sector_count_lba:
    ld bc, #ff50                         ; Ide_Reg_Sectors
    out (c), a                           ;
    ld a, ixl                            ;
    ld c, #70                            ; Ide_Reg_Lbalo
    out (c), a                           ;
    ld a, ixh                            ;
    ld c, #90                            ; Ide_Reg_Lbamid
    out (c), a                           ;
    ld a, e                              ;
    ld c, #b0                            ; Ide_Reg_Lbahi
    out (c), a                           ;
    ret                                  ;
; IN  - A    - sectors count
; IN  - EIX  - lba
; OUT - AF   - garbage
; OUT - BC   - garbage
; OUT - HL   - garbage
idedrv_smuc_out_sector_count_lba:
    ld bc, #fabe                         ; Ide_Reg_Sectors
    call trdos_out                       ;
    ld a, ixl                            ;
    ld b, #fb                            ; Ide_Reg_Lbalo
    call trdos_out                       ;
    ld a, ixh                            ;
    ld b, #fc                            ; Ide_Reg_Lbamid
    call trdos_out                       ;
    ld a, e                              ;
    ld b, #fd                            ; Ide_Reg_Lbahi
    jp trdos_out                         ;

; IN  - HL  - dst address
; OUT - HL  - next untouched dst address
; OUT - AF  - garbage
; OUT - BC  - garbage
idedrv_divide_read_256b:
    ld bc, #00a3                         ; Ide_Reg_Data
    inir                                 ;
    ret                                  ;
; IN  - B   - bytes count
; IN  - HL  - dst address
; OUT - HL  - next untouched dst address
; OUT - AF  - garbage
; OUT - BC  - garbage
; OUT - IXL - garbage
idedrv_nemoide_read_256b:
    ld ixl, 0                            ;
1:  ld bc, #ff10                         ; Ide_Reg_Data lo
    in a, (c)                            ;
    ld (hl), a                           ;
    inc hl                               ;
    dec ixl                              ;
    inc bc                               ; Ide_Reg_Data hi
    in a, (c)                            ;
    ld (hl), a                           ;
    inc hl                               ;
    dec ixl                              ;
    jr nz, 1b                            ;
    ret                                  ;
; IN  - HL  - dst address
; OUT - HL  - next untouched dst address
; OUT - AF  - garbage
; OUT - BC  - garbage
; OUT - IXL - garbage
idedrv_smuc_read_256b:
    push de                              ;
    ex de, hl                            ;
    ld ixl, 0                            ;
    ld c, #be                            ;
1:  ld b, #f8                            ; Ide_Reg_Data lo
    call trdos_in                        ;
    ld (de), a                           ;
    inc de                               ;
    dec ixl                              ;
    ld b, #d8                            ; Ide_Reg_Data hi
    call trdos_in                        ;
    ld (de), a                           ;
    inc de                               ;
    dec ixl                              ;
    jr nz, 1b                            ;
    ex de, hl                            ;
    pop de                               ;
    ret                                  ;



; OUT - F   - Z on success, NZ on fail
; OUT - A   - garbage
; OUT - BC  - garbage
; OUT - D   - garbage
; OUT - HL  - garbage
ide_drive_select:
    ld a, (var_int_counter)              ;
    add a, IDE_INIT_TIMEOUT              ;
    ld d, a                              ;
    ; call .wait                           ;
    ; ret nz                               ;
.set:
.D  ld a, #ff                            ; disk id (DRV and LBA bits)
    call idedrv_out_lbaex_drive_head     ;
.wait:
    ld a, (var_int_counter)              ; check timeout
    cp d                                 ; ...
    jr nz, 1f                            ; ...
    or 1                                 ; ... set NZ flag
    ret                                  ; ...
1:  call idedrv_in_status                ; >=400 ns after .set
    and Ide_St_BSY | Ide_St_DRDY         ;
    cp Ide_St_DRDY                       ;
    jr nz, .wait                         ;
    ret                                  ;


; OUT - F  - Z on success, NZ on fail
; OUT - A  - garbage
; OUT - BC - garbage
; OUT - DE - garbage
; OUT - HL - garbage
; OUT - IX - gatbage
ide_init:
.D  ld a, #ff                            ; disk id (DRV and LBA bits)
    call idedrv_out_lbaex_drive_head     ;
    xor a : ld e, a : ld ix, 0           ;
    call idedrv_out_sector_count_lba     ;
    ld a, Ide_Cmd_Identify_Device        ;
    call idedrv_out_command              ;
    ld a, (var_int_counter)              ;
    add a, IDE_INIT_TIMEOUT              ;
    ld d, a                              ;
.busy:
    ld a, (var_int_counter)              ; check timeout
    cp d                                 ; ...
    jr z, .err                           ; ...
    call idedrv_in_status                ; wait until BSY disappears
    rlca                                 ; ...
    jr c, .busy                          ; ...
    bit 4, a                             ; some drives might assert DRQ even on error
    jr z, .err                           ;
    ld hl, disk_buffer                   ; read identify data
    push af                              ;
    call idedrv_read_256b                ; ...
    call idedrv_read_256b                ; ...
    pop af                               ;
    and Ide_St_DF<<1 | Ide_St_ERR<<1     ;
    jr nz, .err                          ;
.check_lba_aviability:
    ld a, (disk_buffer+Ide_Id_Caps+1)    ;
    and 2                                ; we dont support ancient chs hdds
    jr z, .err                           ;
.check_lba_sanity:
    ld hl, disk_buffer+Ide_Id_Lba        ; check lba != 0x00000000 && lba != 0xffffffff
    ld a, 0                              ; ...
    cpi : jr nz, 1f                      ; ...
    cpi : jr nz, 1f                      ; ...
    cpi : jr nz, 1f                      ; ...
    cpi : jr nz, 1f                      ; ...
1:  ld hl, disk_buffer+Ide_Id_Lba        ; ...
    ld a, #ff                            ; ...
    cpi : jr nz, .exit                   ; ...
    cpi : jr nz, .exit                   ; ...
    cpi : jr nz, .exit                   ; ...
    cpi : jr nz, .exit                   ; ...
.err:
    or 1                                 ;
    ret                                  ;
.exit:
    xor a                                ;
    ret                                  ;


; IN  - DEBC - src lba
; IN  - HL   - dst address of 512-byte buffer
; OUT - F    - Z on success, NZ on fail
; OUT - HL   - next untouched dst address
; OUT - A    - garbage
; OUT - BC   - garbage
; OUT - DE   - garbage
; OUT - IX   - garbage
ide_read_block:
    push hl                              ;
    push bc                              ;
    ld a, d                              ; if lba >= 2^28 - use lba48
    and #f0                              ; ...
.D  ld a, #ff                            ; disk id (DRV and LBA bits)
    jr nz, .lba48                        ; ...
.lba28:
    or d                                 ;
    call idedrv_out_lbaex_drive_head     ;
    ld a, 1                              ;
    pop ix                               ;
    call idedrv_out_sector_count_lba     ;
    ld a, Ide_Cmd_Read_Sectors           ;
    jr .go                               ;
.lba48:
    call idedrv_out_lbaex_drive_head     ;
    xor a : ld ixh, a : ld ixl, d        ;
    ld d, e : ld e, a                    ;
    call idedrv_out_sector_count_lba     ;
    ld a, 1 : ld e, d                    ;
    pop ix                               ;
    call idedrv_out_sector_count_lba     ;
    ld a, Ide_Cmd_Read_Sectors_Ext       ;
.go:
    call idedrv_out_command              ; send command
    ld a, (var_int_counter)              ;
    add a, IDE_READ_TIMEOUT              ;
    ld e, a                              ;
.wait_ready:
    call idedrv_in_status                ;
    bit 7, a                             ; BSY?
    jr z, 1f                             ;
    ld a, (var_int_counter)              ; timeout expired?
    cp e                                 ; ...
    jr z, .err_pop1                      ; ...
    jr .wait_ready                       ;
1:  bit 3, a                             ; DRQ?
    jr z, .err_pop1                      ;
    ld d, a                              ;
.read:
    pop hl                               ;
    call idedrv_read_256b                ;
    call idedrv_read_256b                ;
    ld a, d                              ;
    and Ide_St_DF | Ide_St_ERR           ;
    jr nz, .err                          ;
.success:
    xor a                                ; set Z flag
    ret                                  ;
.err_pop1:
    pop hl                               ;
.err:
    or 1                                 ; set NZ flag
    ret                                  ;
